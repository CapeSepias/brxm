<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo
  
  Licensed under the Apache License, Version 2.0 (the  "License"); 
  you may not use this file except in compliance with the License. 
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" 
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  See the License for the specific language governing permissions and 
  limitations under the License.
-->
<document>
  <properties>
    <title>Frontend Plugin Communication</title>
  </properties>
  <body>
    <section name="Frontend Plugin Communication">
      <p>
        Each frontend plugin in itself is an independent GUI component. All frontend plugins together however
        form a complete application. Within such an application context, plugins are no longer independent,
        and need to communicate with each other. One plugin might cause an event, on which certain other plugins
        might react (by performing whatever action). Yet other plugins may stay unaffected. Which plugins react
        on which other plugins, is configured by means of "channels" in the frontend plugin configuration.
      </p>

      <subsection name="Channels">
        <p>
          A channel is a medium through which plugin events are communicated. For each plugin, any number of
          incoming and outgoing channels can be configured. A channel is identified by a string.
        </p>
        <p>
          When a plugin sends an event (e.g. a node has been selected), it is broadcasted on each of the outgoing
          channels configured for that plugin. Then for each plugin which has an incoming channel configured which
          matches any of the channels on which the event was broadcasted, that plugin's update() method is called.
          Within its update() method, a plugin can do with the event whatever it considers necessary, e.g. updating
          its model and view.
        </p>
        <p>
          It is important to understand that plugins have no knowledgde of channels. Plugins sends events through
          the plugin manager. The plugin manager reads the configured channels and notifies the affected plugins
          by calling their update() method.
        </p>
      </subsection>
      
      <subsection name="Events">
        <p>
          Plugin events are the means of communication between plugins. The unit of communication however is a
          JcrNodeModel, which is contained within the PluginEvent. This JcrNodeModel tells the receivers of the
          event which JCR node has been selected, created, changed, or removed. To indicate what kind of event
          has occurred, an event type must be specified. There are two predefined event types:
        </p>
        <ul>
          <li>
            JcrEvent.NEW_MODEL
          </li>
          <li>
            JcrEvent.NEEDS_RELOAD
          </li>
        </ul>
      </subsection>
      
      <subsection name="Example">
        <p>
          A PluginEvent is created using three parameters: the plugin responsable for the event, the type of event, and
          the JcrNodeModel representing the affected node in the repository. Using the PluginManager, the event can
          then be broadcasted. For this, an AjaxRequestTarget is necessary, so the receiving plugins can update
          their view if necessary.
        </p>
        <source>
<![CDATA[PluginEvent event = new PluginEvent(this, JcrEvent.NEW_MODEL, getNodeModel());
getPluginManager().update(target, event);]]>
        </source>
        <p>
          To let a plugin react on an event, the update method needs to be implemented.
        </p>
        <source>
<![CDATA[public void update(AjaxRequestTarget target, PluginEvent event) {
    // get the JcrNodeModel from the event
    JcrNodeModel newModel = event.getNodeModel(JcrEvent.NEW_MODEL);
     
    // update the plugin's model
    if (newModel != null) {
        setNodeModel(newModel);
    }
    
    // update the plugin's view
    if (target != null && findPage() != null) {
        target.addComponent(this);
    }
}]]>
        </source>
      </subsection>
      
      <subsection name="Configuration">
        <p>
          Incoming and outgoing channels are configured in the frontend plugin configuration, which
          is typically stored in the repository. Two multivalue properties, "hippo:incoming" and
          "hippo:outgoing", list the incoming and outgoing channels for a plugin.
        </p>
        <p>
          Example:
        </p>
        <source>
browserPlugin: [hippo:frontendplugin]
  hippo:renderer: org.hippoecm.cmsprototype.frontend.plugins.foldertree.FolderTreePlugin
  hippo:incoming: {browsing}
  hippo:outcoming: {browsing, details}
        </source>
        <p>
          The example above shows the configuration for a "browser plugin". In addition to the
          "renderer" (the plugin class, FolderTreePlugin), the incoming and outgoing channels for this plugin
          are specified. This plugin has one incoming channel ("browsing"), and two outgoing
          channels ("browsing" and "details"). So this plugin broadcasts events on the "browsing" channel,
          and it listens to the "browsing" channels as well. This means this plugin needs to react
          on its own events (e.g. when a node in the tree is expanded, the view needs to be updated).
          The second outgoing channel ("details") is very likely being listened to by some plugin(s)
          showing details of the node selected in the tree. The browser plugin does not know this
          however.
        </p>
        <p>
          Note that the configuration is stored in the repository, so it can be edited using the
          console frontend application.
        </p>
      </subsection>

    </section>

  </body>
</document>
