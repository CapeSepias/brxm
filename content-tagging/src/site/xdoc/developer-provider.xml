<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
    Copyright 2007-2013 Hippo B.V. (http://www.onehippo.com)
    
    Licensed under the Apache License, Version 2.0 (the  "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
    http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS"
    BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<document>
    <properties>
        <title>Developer Guide - Creating your own tags provider</title>
    </properties>
    <body>
        <section name="Developer Guide - Creating your own tags provider">
            <p>
            	This section will explain how you can create your own tag provider.
            </p>
            <p>
            	This can be useful if you want to search for tags on a special way.
            	Your document type may have a property that has a special meaning in
            	relation to other documents and you want to take advantage of that
            	in the way you suggest tags.
            </p>
            
            <subsection name="What is a tags provider?">
            	<p>
            		<i>A tags provider is no more than a Java class that extends AbstractTagsProvider 
            		and implements the getTags method.</i> To make the provider active you need to 
            		configure it in a plugin cluster in the console. 
            	</p>
            </subsection>
            
            <subsection name="A simple example">
            	<p>
            		Below is a very simple provider. It suggest all tags it can find.
            	</p>
            	<source>
public class AllTagsProvider extends AbstractTagsProvider {

    public final static String SCORE = "score";
    public final static String TAGS_INDEX = "tags.index";

    private double score;
    private String tagsIndex; 

    public AllTagsProvider(IPluginContext context, IPluginConfig config) {
        super(context, config);
        score = config.getDouble(SCORE, 0.1);
        tagsIndex = config.getString(TAGS_INDEX);
    }

    public TagCollection getTags(JcrNodeModel nodeModel) throws RepositoryException {
    	Session session = nodeModel.getNode().getSession();
        TagCollection tags = new TagCollection();
        // retrieve the facetsearch
        NodeIterator iterator = session.getRootNode().getNode(tagsIndex).getNodes();
        while (iterator.hasNext()) {
            Node tagNode = iterator.nextNode();
            if (tagNode.getPrimaryNodeType().getName().equals(HippoNodeType.NT_FACETSUBSEARCH)) {
                Tag tag = new Tag(ISO9075Helper.decodeLocalName(tagNode.getName()), tagNode.getProperty("hippo:count")
                        .getLong() * score);
                tags.add(tag);
            }
        }
        return tags;
    }
}
            	</source>
            	<p>
            		This provider uses the document (JcrNodeModel) only to retrieve the
            		repository session. Then it just retrieves all the nodes found in the
            		facetsearch (the facetsearch lists all the tags found in the repository).
            	</p>
            </subsection>
            
            <subsection name="The tags index">
            	<p>
            		To speed up searching for tags, the tags property is indexed. When you look 
            		closely at the above example, you will see that we retrieve the location of
            		the tags index in the constructor. We later use that location in the getTags
            		method to retrieve the facetsearch node (to construct the NodeIterator). 
            	</p>
            	<p>
            		One should use the tags index as much as possible as it is much more efficient
            		than iterating through the nodes yourself or using XPath or SQL.
            	</p>
            </subsection>
            
        </section>
    </body>
</document>
