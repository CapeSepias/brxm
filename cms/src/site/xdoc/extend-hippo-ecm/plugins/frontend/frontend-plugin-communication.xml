<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo

  Licensed under the Apache License, Version 2.0 (the  "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS"
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
  <properties>
    <title>Frontend Plugin Communication</title>
  </properties>
  <body>
    <section name="Frontend Plugin Communication">
      <p>
        Each frontend plugin in itself is an independent component.  All
        frontend plugins together however form a complete application.  Within
        such an application context, plugins are no longer independent, and
        need to communicate with each other.  One plugin might cause an event,
        on which certain other plugins might react (by performing whatever
        action).  Yet other plugins may stay unaffected.
      </p>

      <subsection name="Sharing Models">
        <p>
          A very simple communication mechanism is provided in the form of
          sharing models between plugins.  When one plugin provides an
          IModelService (a Perspective will do this for you), others can
          use it to obtain their IModel and to receive "model change"
          notifications.
        </p>
        <p>
          The straightforward way to use this mechanism is to subclass the
          RenderPlugin and override the onModelChanged() method.  Whenever
          the model changes in one of the other plugins, it will be invoked.
          If the plugin needs to be redrawn in response to the model update,
          call redraw().
        </p>
        <p>
          This occurs for example when the page contains a BrowserPlugin.  When
          a node is selected on the (JCR) tree, other plugins are notified.
          This mechanism is e.g. used to show workflow plugins for nodes
          that have a workflow.
        </p>
        <source>
<![CDATA[public class ExamplePlugin extends RenderPlugin {

  public ExamplePlugin(IPluginContext context, IPluginConfig config) {
    super(context, config);
  }

  @Override
  public void onModelChanged() {
    // repaint the plugin when the model has changed.
    redraw();
  }

}]]>
        </source>
      </subsection>

      <subsection name="Dialogs / Page Serialization">
        <p>
          Wicket has a serialization mechanism that necessitates careful design
          when multiple Page instances are involved.  When Wicket serializes
          the object graph, different pages are written out to different pagemaps.
          This imposes constraints on the object graphs that have to be taken into
          account when dealing with multiple pages.
        </p>
        <p>
          This issue is not specific to the plugin architecture, in fact every
          Wicket application needs to address this problem in one way or the
          other.  The plugin architecture does offer a solution when the
          objects involved are services.
        </p>
        <p>
          Since dialogs are separate pages, I'll use one to illustrate the
          point.  The dialog uses a service that changes its state when a link
          is clicked.
        </p>
        <source>
<![CDATA[public class ExampleDialog extends WebPage {

  private IServiceReference<IFlagService> serviceRef;

  public ExampleDialog(IPluginContext context, IFlagService service) {
    serviceRef = context.getReference(service);

    add(new AjaxLink("hello") {

      public void onClick(AjaxRequestTarget target) {
        IFlagService flagService = serviceRef.getService();

        if (flagService != null) {
          flagService.setFlag(true);
        }
      }
    });
  }

}]]>
        </source>
        <p>
          The naive implementation would have made the service argument final,
          skipping the IServiceReference intermediary.  Comparing the two
          approaches in the order of events:
        </p>
        <dl>
          <dt>Main page is serialized</dt>
          <dd>
            When the request that created the dialog is completed, the main page
            (the one creating the dialog) is serialized.  During this process,
            Wicket will encounter a reference to the service and will write it out
            to the pagemap.
          </dd>
          <dt>Dialog receives request</dt>
          <dd>
            <p>Assuming that the user clicks the "hello" link, the dialog will receive
            a request that is handled by the onClick() method.  The service will be
            invoked.  In the two scenarios:</p>
            <ul>
              <li>
                in the naive implementation, the original (service) object will
                be used.  Changes that are made as a result of the setFlag()
                call are persisted in the dialog pagemap, but will be invisible
                to the main page.  This is NOT GOOD<sup>TM</sup>.
              </li>
              <li>
                in the shown example, the IServiceReference implementation does
                not store a direct reference to the service.  Instead it
                deserializes the original page when getService() is invoked and
                looks up the service.  At the end of the request, the original
                (updated) page is serialized again.  SUCCES!
              </li>
            </ul>
          </dd>
        </dl>
      </subsection>

    </section>

    <section name="Advanced - Subject to Change">
      <p>
        This section describes some of the patterns that are used in the
        implementation of the CMS.  Beware that when you use this information
        to create plugins that integrate with the CMS, compatibility with
        future releases is not guaranteed.
      </p>

      <subsection name="Other Communication Patterns">
        <p>
          More advanced interactions between plugins can be achieved by
          registering services and/or trackers.  Any object that implements
          IClusterable can be registered as a service.  A number of patterns
          have emerged in the use of this basic premise.
        </p>
        <dl>
          <dt>Whiteboard Pattern</dt>
          <dd>
            <p>
              In the whiteboard pattern, the basic principle of "don't call us,
              we'll call you" is applied to a client/server situation.  When
              several clients need to be notified, they don't register themselves
              directly with the server.  Instead, they register a listener
              service with the plugin context.  When the clients must be
              notified, the server retrieves the list of listeners and notifies
              them.
            </p>
            <p>
              This pattern is actually used by the model sharing implementation.
              Each plugin that wants to be notified of model changes registers
              an IModelListener.  The ModelService uses these listener services
              whenever a model changes.
            </p>
          </dd>
          <dt>Decorator Pattern</dt>
          <dd>
            <p>
              Sometimes it is desirable to extend services with extra
              interfaces.  An example is the ITitleDecorator; it is used by the
              Perspective to provide a title to display for the tabbed panel.
            </p>
          </dd>
        </dl>
      </subsection>

      <subsection name="Available Services">
        <p>
          Some common services are provided by the framework and can be
          retrieved under well-known names.
        </p>
        <dl>
          <dt>IDialogService</dt>
          <dd>
            This service gives plugins, even those without any visual parts,
            the possibility to display modal dialogs.  It can be found under
            the name IDialogService.class.getName() [FIXME: wishful thinking!].
            Showing a dialog is therefore as simple as:
            <source>
<![CDATA[    IDialogService dialogService = context.getService(IDialogService.class.getName(), IDialogService.class);
    dialogService.show(new ExampleDialog(context, flagService));]]>
            </source>
          </dd>
          <dt>IJcrService</dt>
          <dd>
            <p>
              Plugins that use the JCR repository need to refresh their models
              and may need to update their visual representation as a result of
              changes made in other plugins.  The cooperation that is required
              between these plugins is mediated by the global IJcrService
              service.
            </p>
            <p>
              When a plugin makes changes to the repository, it can notify
              other plugins by calling the flush() operation on the IJcrService:
            </p>
            <source>
<![CDATA[public class JcrExamplePlugin extends RenderPlugin {

  public JcrExamplePlugin(final IPluginContext context, IPluginConfig config) {
    super(context, config);

    add(new AjaxLink("clickme") {

      public void onClick(AjaxRequestTarget target) {
        JcrNodeModel nodeModel = new JcrNodeModel("/mycontent/clicknode");
        try {
          // set a property
          Node node = nodeModel.getNode();
          node.setProperty("clicked", true);
          node.save();
        } catch (RepositoryException ex) {
          // add some error logging here, please
        }

        IJcrService jcrService = context.getService(IJcrService.class.getName(), IJcrService.class);
        if (jcrService != null) {
          jcrService.flush(nodeModel);
        }
    });
  }

}]]>
            </source>
            <p>
              Plugins that want to be notified of these events, need to
              implement the IJcrNodeModelListener interface and register
              themselves.  This is an example of the <em>Whiteboard
              Pattern</em>, where listeners can register independent of the
              availability of the jcr service itself.  (I know, this service is
              always available, please use your imagination here)
            </p>
            <source>
<![CDATA[public class JcrListenerPlugin extends RenderPlugin implements IJcrNodeModelListener {

  private IModel model;

  public JcrListenerPlugin(final IPluginContext context, IPluginConfig config) {
    super(context, config);

    // register self to receive jcr flush notifications
    context.registerService(this, IJcrService.class.getName());

    // add a label that displays the state of the node
    model = new IModel("not clicked");
    add(new Label("label", model));
    update();
  }

  public void onFlush(JcrNodeModel nodeModel) {
    // update the label if the flushed node is the one
    // we're interested in or one of its ancestors.
    if ("/mycontent/clicknode".startsWith(nodeModel.getItemModel().getPath())) {
      update();
      redraw();
    }
  }

  private void update() {
    JcrNodeModel nodeModel = new JcrNodeModel("/mycontent/clicknode");
    try {
      Node node = nodeModel.getNode();
      if (node.getProperty("clicked").getBoolean()) {
        model.setObject("clicked");
      }
    } catch (RepositoryException ex) {
      // log error
    }
  }

}]]>
            </source>
          </dd>
          <dt>IPluginConfigService</dt>
          <dd>
            <p>
              The IPluginConfigService makes configurations of clusters of
              plugins available.  It can be found under the name
              IPluginConfigService.class.getName() .  It can be used to
              dynamically instantiate clusters of plugins.
            </p>
            <p>
              As an example, consider the case of multiple editors in the CMS.
              Each editor has its own set of plugin instances and its own
              (node) model.  To satisfy this last requirement, each editor
              uses a separate ModelService, configured by the plugin that
              instantiates editors.
            </p>
          </dd>
        </dl>
      </subsection>

    </section>

  </body>
</document>
