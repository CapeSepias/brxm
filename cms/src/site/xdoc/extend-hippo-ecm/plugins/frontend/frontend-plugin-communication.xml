<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo

  Licensed under the Apache License, Version 2.0 (the  "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS"
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
  <properties>
    <title>Frontend Plugin Communication</title>
  </properties>
  <body>
    <section name="Frontend Plugin Communication">
      <p>
        Each frontend plugin in itself is an independent GUI component.  All frontend plugins together however
        form a complete application. Within such an application context, plugins are no longer independent, and
        need to communicate with each other.  One plugin might cause an event, on which certain other plugins
        might react (by performing whatever action).  Yet other plugins may stay unaffected.
      </p>

      <subsection name="Models">
        <p>
          In an application, plugins can share a model and send messages when this model changes.  Control of the
          model is effectively assigned to the plugin that handles the requests that are related to it.  Some of
          the models are:
        </p>

        <ul>
          <li>
            <p>
              "The selected node": a JcrNodeModel that identifies a node in the repository.  Many plugins use a
              model of this type, e.g. in the browser or editor perspective.  In the CMS configuration, these
              perspectives handle requests to change this selection.
            </p>
          </li>
          <li>
            <p>
              "The selected tab": one of the tabs that is managed by the TabsPlugin.  The TabsPlugin updates this
              model when one of the perspectives requests focus.
            </p>
          </li>
          <li>
            <p>
              "The JCR cache": a JcrTreeModel that reflects the hierarchy of nodes in the repository in the frontend.
              As this model changes when nodes are added or removed, the cached hierarchy is flushed and re-read.
            </p>
          </li>
        </ul>
      </subsection>

      <subsection name="Messages">
        <p>
          Each plugin has two channels, one connecting it to its parent plugin ("incoming") and one connecting it
          to its children ("outgoing").  Plugins effectively act as filters on the message streams.  There are
          two kinds of messages:
        </p>

        <ul>
          <li>
            <p>
              <em>Requests</em>: When a plugin wishes to change a model that is shared with other plugins, it must
              send a request to its parent plugin.  If the parent does not control the model, it should forward the
              request further up the hierarchy.
            </p>
          </li>
          <li>
            <p>
              <em>Notifications</em>: these messages are received through the channel that connects a plugin with its
              parent.  They are sent when a model changes and the plugin should update its copy of the model.  The
              message should be forwarded to the children of the plugin, so that they can take action as well.
            </p>
          </li>
        </ul>

        <p>
          Each message consists of an operation and a model.  The operation is a String such as "select", the
          model is of type IPluginModel.  The model is weakly typed, i.e. all accessible objects are of type
          java.*, but should contain sufficient information to reconstruct the object upon which the operation
          should be (request) or has been (notification) applied.  There is one plugin in the hierarchy that
          handles the request and will send notifications if necessary.  A plugin nested deeply in the hierarchy
          can thus request a change in an ancestor plugin, but it is up to the ancestor (configuration) how it
          interprets the request and whether it even accepts it.
        </p>

        <p>
          The following messages are currently used:
        </p>

        <ul>
          <li><p>edit: the associated node should be opened in an editor</p></li>
          <li><p>browse: the node should be shown in a browser</p></li>
          <li><p>select: the associated node should be selected</p></li>
          <li><p>flush: caches of JCR nodes under the node in the message should be flushed</p></li>
          <li><p>focus: the associated plugin should receive focus</p></li>
        </ul>
      </subsection>

      <subsection name="Ajax">
        <p>
          To support Ajax updates of the page, each message has a MessageContext.  Plugins can request a
          redrawing by adding themselves to this context when processing a message.  Wicket entry points for
          (e.g. onClick) that send requests or notifications should apply the AjaxRequestTarget to this context.
          When a new message is created in response to another message, the original context should be attached
          to the new message.
        </p>

        <p>
          When a plugin should be re-rendered as a result of receiving a message, it adds itself to the
          context.  The plugin may be invisible at the time of reception, but this may change later as 
          messages cascade through the plugin configuration.  A plugin should therefore always add itself when
          its visual representation would change, were it visible.
        </p>
      </subsection>

      <subsection name="Filter Plugin">
        <p>
          To separate the control over a model from any visual components, the FilterPlugin has been created.
          This non-visual plugin can be configured to handle requests in a trivial manner.  A request is
          converted into a notification with the same operation and model.
        </p>
      </subsection>

      <subsection name="Example">
        <p>
          As an example, here is how to send a request from a Wicket entry point:
        </p>
        <source>
<![CDATA[public void onClick(AjaxRequestTarget target) {
    // Create a request to select the model for this plugin
    PluginDescriptor descriptor = getDescriptor();
    Channel incoming = descriptor.getIncoming();
    Request request = incoming.createRequest("select", getPluginModel());
    incoming.send(request);

    // Render plugins that have been updated
    MessageContext context = request.getContext();
    context.apply(target);
}]]>
        </source>
        <p>
          To handle notifications, the receive method should be overridden:
        </p>
        <source>
<![CDATA[public void receive(Notification notification) {
    if ("select".equals(notification.getOperation())) {
        // Create a new JcrNodeModel
        JcrNodeModel model = new JcrNodeModel(notification.getModel());

        // Select the new model if it differs from the current one
        if (!model.equals(getPluginModel())) {
            setPluginModel(model);

            // rerender the plugin
            notification.getContext().addRefresh(this);
        }
    }

    // forward the notification to children
    super.receive(notification);
}]]>
        </source>
      </subsection>

    </section>

  </body>
</document>
