<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo
  
  Licensed under the Apache License, Version 2.0 (the  "License"); 
  you may not use this file except in compliance with the License. 
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" 
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  See the License for the specific language governing permissions and 
  limitations under the License.
-->
<document>
  <properties>
    <title>Frontend Plugin Architecture</title>
  </properties>
  <head>
  </head>
  <body>
    <section name="Frontend Plugin Architecture">
    
      <p>
        Hippo ECM provides an <a href="http://wicket.apache.org">Apache Wicket</a> based
        plugin architecture to facilitate a customizable GUI. All standard GUI components are written
        as plugins. The Hippo CMS application offers a default configuration for these plugins.
        Customizing Hippo CMS comes down to extending the standards plugins, and/or writing your own,
        and configuring them to form your own custom application.
      </p>
      
      <subsection name="Customization by configuration">
      
        <p>
          Frontend plugins extend the Wicket component model.  Wicket HTML fragments 
          can contain references to plugins that are not added explicitly in the Java code. Instead,
          these references are resolved by the configuration in the repository.
        </p>
        
        <p>
          Example: suppose we have an ordinary Wicket panel called RootPanel, which contains three child
          panels: a ListPanel, a TreePanel and a SimplePanel. The child panels would need to be added
          explicitly in code, for example in the constructor or RootPanel:
        </p>
<source>
class RootPanel extends Panel {          

  public RootPanel {
    add("list", new ListPanel());
    add("tree", new TreePanel());
    add("custom", new SimplePanel());
  }        

}
</source>
        <p>
          This means that replacing SimplePanel with e.g. AdvancedPanel implies recompilation
          of the code. Frontend plugins however need not be added explicitly in code, so if we make
          our RootPanel a RootPlugin, its constructor can remain empty:
        </p>
<source>
class RootPlugin extends Plugin {

  public RootPlugin() {
  
  }        

}
</source>
        <p>
          The child plugins are added instead through configuration:
        </p>
<source>
root:
  class = org.example.RootPlugin
  children = {list, tree, custom}
list:
  class = org.example.ListPlugin
  children = {}
tree:
  class = org.example.TreePlugin
  children = {}
custom:
  class = org.example.SimplePlugin
  children = {}
</source>
        <p>
          Changing the SimplePlugin to an AdvancedPlugin now only involves changing the configuration.
          No recompilation is needed.
        </p>
        <p>
          This configuration is stored in the repository in nodes of (primary) type <b>hippo:frontendplugin</b>.
          The property <b>hippo:renderer</b> determines what Java class is instantiated.
        </p>
      </subsection>

      <subsection name="Applications">
        <p>
          Web applications that are completely configured from the repository consist of one page,
          "Home". Each application's plugin configuration is stored in the repository under
          <b>/hippo:configuration/hippo:frontend</b>. The example below shows two
          application configurations ("foo" and "bar").
        </p>
<source>
[repository root]
`-- hippo:configuration
    `-- hippo:frontend
        |-- foo [hippo:page]
        `-- bar [hippo:page]
</source>
      </subsection>

      <subsection name="Plugins">
        <p>
          The Home page in each application always has a root plugin that is loaded when Wicket tries
          to render it. This plugin must be a subclass of org.hippoecm.frontend.plugin.Plugin,
          itself a Wicket Panel. An example:
        </p>
<source>
public class RootPlugin extends Plugin {
    private static final long serialVersionUID = 1L;

    public RootPlugin(PluginDescriptor pluginDescriptor, JcrNodeModel model, Plugin parentPlugin) {
        super(pluginDescriptor, model, parentPlugin);
    }

}
</source>
        <p>
          When the class is instantiated, the children of the repository node are instantiated
          themselves as Plugins and added as Wicket components.
        </p>

        <p>
          The plugins that are configured in the repository node structure must therefore
          correspond to missing Wicket components in the HTML for RootPlugin.  For example,
          if the above root component has this html:
        </p>
<source>
&lt;html xmlns:wicket="http://wicket.apache.org/"&gt;
    &lt;wicket:panel&gt;
      &lt;p&gt;
        &lt;div wicket:id="subPlugin">[sub plugin will be rendered here]&lt;/div&gt;
      &lt;/p&gt;
    &lt;/wicket:panel&gt;
&lt;/html>
</source>
        <p>
          then the repository structure that will generate the correct component hierarchy is:
        </p>
<source>
[repository root]
`-- configuration
    `-- frontend
        `-- application [hippo:page]
            `-- RootPlugin [hippo:frontendplugin]
                `-- subPlugin [hippo:frontendplugin]
</source>
        <p>
          Both hippo:frontendplugin nodes, RootPlugin and subPlugin, need to have a property
          <b>hippo:renderer</b>, which contains the full class name of the plugin.
        </p>
      </subsection>
      
      <subsection name="JcrNodeModel">
        <p>
          Plugins are aware of the JCR context for the page and are 
          <a href="frontend-plugin-communication.html">notified when it changes</a>. This occurs
          for example when the page contains a BrowserPlugin. When a node is selected on the (JCR) tree,
          other plugins are notified. This mechanism is e.g. used to show the workflow plugin for nodes that
          have a workflow.
        </p>
        <p>
          A plugin's model is a JcrNodeModel, which is an IModel representing a node in the
          JCR repository. Internally a plugin can have its own model wrapping the JcrNodeModel
          (the class NodeModelWrapper can be extended for this purpose). 
        </p>
      </subsection>
      
    </section>
  </body>
</document>
