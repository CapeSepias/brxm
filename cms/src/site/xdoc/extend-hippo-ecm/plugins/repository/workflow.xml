<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo

  Licensed under the Apache License, Version 2.0 (the  "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS"
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
    <properties>
        <title>Repository Plugins</title>
    </properties>
    <body>
      <section name="Developing workflows">

<p>
The most common functionality to be added in the repository is the addition of
project specific workflow.  The role of workflow and the access to workflow
steps are described in <a href="../../../use-hippo-ecm/">Workflow
functionality</a>.  A default set of workflow operations is defined in
available plugins.  The extension of workflows is not merely based on
modifications to these available plugins.  Instead, entirely new workflows
with complete new concepts can be developed and added to the repository
without any need to embed this functionality in the repository.
<p>

<p>
To allow workflow to be developed without knowledge of the internals of the
repository, the model of Plain Old Java Objects (POJO) is adopted.  When a
workflow is invoked on a document stored in the repository, then the data of
this document in the repository is mapped to onto a Java object that is
selected by the workflow.
<p>

<p>
The workflow implementation is just a method of a Java class that can modify
this Java object, and does not need to know anything about the repository
itself.  So it can change the state of a document according to it's own
workflow rules by modifying its own representation of the document.

<p>
After the workflow method has executed, the document is persisted back into
the repository.  Because the mapping of content to object and vice versa
(Object-Content Mapping, or OCM) does not need to be a 1-to-1 mapping this
allow for flexibly and independent development.
<p>

<subsection name="Building your own workflow"

<p>
To build your own workflow, you need to:
<p>

<ol>
<li>Write a class and define fields in the class to which the document is
mapped;</li>
<li>Write methods in this class which perform the workflow steps to be
executed;</li>
<li>Define how the fields of this class are mapped to a document in the
repository;</li>
<li>Add a definition in the repository indicating on which documents this
workflow is applicable.</li>
</ol>

<p>
These steps are best explained by a simple example.  To build a workflow that
simply marks a document as &quot;done&quot; we need to run by all the steps
above.  First, this workflow should only be applicable to documents which can
be marked as such, i.e. have at least a property to put this mark in.
<p>

<p>
We will use the example document of JCR node type <code>sample:document</code>
with the following CND definition:
<p>

<source>
<rep='internal'>
<jcr='http://www.jcp.org/jcr/1.0'>
<nt='http://www.jcp.org/jcr/nt/1.0'>
<mix='http://www.jcp.org/jcr/mix/1.0'>
<hippo='http://www.hippoecm.org/nt/1.0'>
<sample='http://www.sample.org/sample/nt/1.0'>

[sample:document] > sample:document
- sample:done (string) mandatory = 'false' < 'true', 'false'
- sample:title (string) mandatory
+ sample:content (nt:unstructured)
</source>

Our workflow will only operate on this type of document, or on documents which
type is derived form this type.

</subsection>

<subsection name="Creating a workflow class">

<p>
A simple class is the Java-representation of the JCR-based document:
<p>

<source>
public class SampleWorkflowImpl {
  private boolean isDone;
}
</source>

<p>
This class is not yet complete as we will see in the next subsection, but note
that the field name in the class does not match the name in the JCR
definition.  Not only does the name not have to match, nor does the mapping
have to be 1-to-1.  So the title property and content subnode are not
represented in the node, their value is not of interest to the workflow.
<p>

</subsection>

<subsection name="Writing the method that performs the workflow step">

<p>
The document representation for <em>this</em> workflow we are writing and the
workflow are represented in a single class.  It is possible to make an
explicit document class object.  For ease of example we proceed with a sinle
class and write the method representing the workflow step inside the same class.
<p>

<p>
The method that performs the workflow step is in principle as simple as:
<p>

<source>
public class SampleWorkflowImpl {
  private boolean isDone;
  public void setDone() {
    isDone = true;
  }
}
</source>

<p>
Although you can fully use a POJO model there are a number of restrictions for
the class that represents the workflow.  Anywhere in the initial class you can
freely define (and let them be constructed through OCM) any other class
instance.
First, in order for a workflow to be accessed from outside the repository,
you should provide an interface with just the methods that are the workflow
actions.
<p>

<p>
Then there are a number of rules the interface and the class should adhere to:
<p>

<ol>
<li>The class should be non-abstract and public;</li>
<li>The class must have a no-argument public constructor;</li>
<li>The class must extend the
<code>org.hippoecm.repository.ext.WorkflowImpl</code> base class;</li>
<li>The class must implement an interface with the methods to be invoked (as
workflow actions);</li>
<li>In the methods that implement the interface should always have a throws
clause for the exceptions <code>WorkflowException</code> and
<code>RepositoryException</code></li>;
<li>A WorkflowException may be thrown if the workflow finds that it cannot
perform the workflow action due to some business rule;</li>
<li>A RepositoryException may not be thrown by the workflow action itself,
but can be the result of the repository itself;</li>
<li>The workflow may use the getWorkflowContext() call from the base class to
get additional information from the repository;</li>
<li>The workflow may however <em>not</em> try to access the repository by any
other means</li>;
<li>Workflows may return serializable objects, or
<code>org.hippoecm.repository.api.Document</code>.  However not subclasses of
the class Document, and the Document instance actually delivered to the
invoker of the workflow is always a direct instance of class Document, not any
sub-type.  So returning a subclass of Document in the workflow is allowed, but
the instance received is a different object instance.</li>
<li>The interface class for the workflow must extend
<code>org.hippoecm.repository.api.Workflow</code>;</li>
<li>The methods the interface class defines should specify to throw the
exceptions <code>WorkflowException</code>, <code>RepositoryException</code>,
and <code>RemoteException</code>;</li>
</ul>

<p>
This leads to the following implementation for the Workflow class:
<p>

<source>
package org.sample;
import javax.jcr.RepositoryException;
import org.hippoecm.repository.api.WorkflowException;
import org.hippoecm.repository.ext.WorkflowImpl;

public class SampleWorkflowImpl extends WorkflowImpl implements SampleWorkflow {
  private boolean isDone;
  public void markDone() {
    if(isDone)
      throw new WorkflowException();
    isDone = true;
  }
}
</source>

<p>
And the interface:
<p>

<source>
package org.sample;
import java.rmi.RemoteException;
import javax.jcr.RepositoryException;
import org.hippoecm.repository.api.Workflow;
import org.hippoecm.repository.api.WorkflowException;
public interface SampleWorkflow extends Workflow {
    public void markDone() throws WorkflowException, RepositoryException, RemoteException;
}
</source>

<p>
In the method implementing the workflow action we can throw the generic
exception WorkflowException if the workflow finds an invalid state.
<p>

</subsection>

<subsection name="Mapping the data in the class to data in the repository">

<p>
The Hippo Repository uses <a href="http://www.jpox.org/">JDO</a> to define the
mapping between JCR and Java objects.  For a detailed description see the JDO
specification and tutorials.  However to perform the mapping, we are not using
a relational model (RDBM), and therefor we need not concern with how to
scatter information to different tables.  Instead we can use the most simplest
mapping in JDO.
<p>

<p>
Simply use identity-type datastore for all classes, and indicate a initial
path in the table.  For the workflow, this can be as simple as "/".  Specify
the datastore-identity to be native.  These are default settings to be used
generically.  The only thing to do then, is to indicate which fields in the
class should be mapped to which properties in the JCR node, for which the
&quot;column&quot; attribute is used, as shown below.
<p>

<p>
This leads to the following definition for the OCM mapping:
<p>

<source>
<!DOCTYPE jdo PUBLIC "-//Sun Microsystems, Inc.//DTD Java Data Objects Metadata 2.0//EN" "jdo2.dtd">
<jdo>
  <package name="org.sample">
    <class name="SampleWorkflowImpl" detachable="true" identity-type="datastore" table="/">
      <datastore-identity strategy="native"/>
      <field name="isDone" column="sample:done"/>
    </class>
  </package>
</jdo>
</source>

<p>
This definition should be stored in a file named <code>package.jdo<code>, and
must be places next to the WorkflowImpl.class file.
</p>

<p>
If you use a maven2 build, this is normally accomplished by creating the file
<code>src/main/resources/org/sample/package.jdo</code> and the Java source is
located at <code>src/main/resources/org/sample/SampleWorkflowImpl</code>.
</p>

</subsection>

<subsection name="Deploying the workflow">

<p>
You can package the workflow implementation and the interface class in a
single JAR.  It is however useful in cases, to make a seperate JAR package for
the interface class, such that other applications have only a dependency on
the interface.  If a workflow is packages in this way, put both JARs in the
repository classpath.
</p>

<p>
The workflow is now known to the repository, but it is unknown to the
repository, when this workflow is applicable.  It should be specified that the
workflow is applicable to sample:document JCR nodes, such that the
WorkflowManager will return access to the workflow when a getWorkflow() call
is made on a sample:document node type.
</p>

<p>
You should configure this in the
<code>/hippo:configuration/hippo:workflows</code> as described in <a
href="../../../run-hippo-ecm/configuration/nodes/workflow.html">Workflow
configuration</a> of the repository configuration.
</p>

</subsection>

      </section>
    </body>
</document>
