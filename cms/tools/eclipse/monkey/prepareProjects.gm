/*
 * Menu: Prepare Hippo ECM projects
 * Script-Path: /hippo-ecm-tools-eclipse/monkey/prepareProjects.gm
 * Kudos: Wander Grevink (onehippo.com)
 * License: Apache 2.0
 * Job: WorkspaceJob
 * Exec-Mode: Foreground
 * DOM: http://groovy-monkey.sourceforge.net/update/plugins/net.sf.groovyMonkey.dom
 */
import org.eclipse.jdt.internal.core.SetClasspathOperation;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.internal.core.ClasspathEntry;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.IClasspathAttribute;
import org.eclipse.core.internal.resources.Workspace;

out.clear();
println "$metadata.menuName started\n";

addProjectDependency('hippo-ecm-quickstart-war', 'hippo-ecm-repository-application');
addProjectDependency('hippo-ecm-quickstart-war', 'hippo-ecm-frontend-application');
addProjectDependency('hippo-ecm-package-war', 'hippo-ecm-repository-application');
addProjectDependency('hippo-ecm-package-war', 'hippo-ecm-frontend-application');

removeClasspathEntry('hippo-ecm-repository-engine', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-standards-frontend', 'src/test/java');
removeClasspathEntry('hippo-ecm-addon-standards-frontend', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-editor', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-cms-edit', 'src/test/java');
removeClasspathEntry('hippo-ecm-addon-cms-edit', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-yui', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-xinha-frontend', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-xinha-frontend', 'src/test/java');
removeClasspathEntry('hippo-ecm-addon-eavesdrop', 'src/test/resources');
removeClasspathEntry('hippo-ecm-addon-faceteddate-repository', 'src/test/resources');
removeClasspathEntry('hippo-ecm-tools-projectexport', 'src/test/resources');

removeProjectDependency('hippo-ecm-addon-xinha-frontend', 'hippo-ecm-frontend-engine-test');
removeProjectDependency('hippo-ecm-addon-cms-edit', 'hippo-ecm-frontend-engine-test');
removeProjectDependency('hippo-ecm-addon-standards-frontend', 'hippo-ecm-frontend-engine-test');
removeProjectDependency('hippo-ecm-tools-projectexport', 'hippo-ecm-addon-builtin-test');

println "\n$metadata.menuName finished";

/////////////

def removeClasspathEntry(projectName, pathPattern) {
    def project = workspace.root.getProject(projectName);
    if (project.isOpen()) {
	    def javaProject = project.getNature('org.eclipse.jdt.core.javanature');
        def classpath = javaProject.getRawClasspath();
        def toBeRemoved = null;
        classpath.each() {
            if (it.getPath().toString().contains(pathPattern)) {
                toBeRemoved = it;
            }
        };
        if (toBeRemoved != null) {
            println "  Removing classpath entry $pathPattern for $projectName";
            def classpathSet = new LinkedHashSet(Arrays.asList(classpath));
            classpathSet.remove(toBeRemoved);
            classpath = (IClasspathEntry[])classpathSet.toArray();
            def op = new SetClasspathOperation(javaProject, classpath, javaProject.getOutputLocation(), true);
            op.runOperation(monitor);
	    } else {
	        println "  $projectName has no classpath entry $pathPattern, leaving as is..";
	    }
	}
}


def addProjectDependency(fromName, toName) {
    def from = workspace.root.getProject(fromName);
    def to = workspace.root.getProject(toName);
    if (from.isOpen() && to.isOpen()) {   
	    def fromProject = from.getNature('org.eclipse.jdt.core.javanature');
	    def classpath = fromProject.getRawClasspath();
	    def classpathSet = new LinkedHashSet(Arrays.asList(classpath));
	    def dependency = new ClasspathEntry(
	        IPackageFragmentRoot.K_SOURCE,     // indicates this classpath entry contains source files.
	        IClasspathEntry.CPE_PROJECT,       // indicates a required project.
	        to.getFullPath(),                  // target project
	        ClasspathEntry.INCLUDE_ALL,        // inclusion patterns
	        ClasspathEntry.EXCLUDE_NONE,       // exclusion patterns
	        null,                              // source attachment
	        null,                              // source attachment root
	        null,                              // specific output folder
	        false,                             // isExported
	        null,                              // accessRules
	        true,                              // combineAccessRules
	        (IClasspathAttribute[])[]          // extraAttributes
	    );        
	    classpathSet.add(dependency);
	    
	    if (classpathSet.size() > classpath.length) {
	        println "  Adding project dependency from $fromName to $toName";
	    	classpath = (IClasspathEntry[])classpathSet.toArray();
	    	def op = new SetClasspathOperation(fromProject, classpath, fromProject.getOutputLocation(), true);
	    	op.runOperation(monitor);
	    } else {
            println "  Project dependency from $fromName to $toName already exists, leaving as is..";
        }
    }
}

def removeProjectDependency(fromName, toName) {
    def from = workspace.root.getProject(fromName);
    def to = workspace.root.getProject(toName);
    if (from.isOpen() && to.isOpen()) {   
        def fromProject = from.getNature('org.eclipse.jdt.core.javanature');
        def classpath = fromProject.getRawClasspath();
        def path = to.getFullPath();
        def toBeRemoved = null;
        classpath.each() {
            if (it.getPath().toString().contains(toName)) {
                toBeRemoved = it;
            }
        };
        if (toBeRemoved != null) {
            println "  Removing project dependency from $fromName to $toName";
            def classpathSet = new LinkedHashSet(Arrays.asList(classpath));
            classpathSet.remove(toBeRemoved);
            classpath = (IClasspathEntry[])classpathSet.toArray();
            def op = new SetClasspathOperation(fromProject, classpath, fromProject.getOutputLocation(), true);
            op.runOperation(monitor);
        } else {
            println "  $fromName has no project dependency to $toName, leaving as is..";
        }
    }
}



