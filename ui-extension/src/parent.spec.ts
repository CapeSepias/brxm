/*
 * Copyright 2018 Hippo B.V. (http://www.onehippo.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Disable TSLint for imports that start with an uppercase letter
 * @see https://github.com/Microsoft/tslint-microsoft-contrib/issues/387
 */
import Emittery = require('emittery'); // tslint:disable-line:import-name
import Penpal from 'penpal';           // tslint:disable-line:import-name
import { connect, Parent, ParentConnection } from './parent';

jest.mock('penpal');

// save globals that may be replaced in tests
const connectToParent = Penpal.connectToParent;

// reset mocked globals after each test
afterEach(() => {
  Penpal.connectToParent = connectToParent;
  (Penpal.connectToParent as jest.Mock).mockClear();
});

describe('connect', () => {
  let parentOrigin: string;
  let eventEmitter: Emittery;

  beforeEach(() => {
    parentOrigin = 'http://cms.example.com:8080';
    eventEmitter = new Emittery();
  });

  it('connects to the parent API', () => {
    return connect(parentOrigin, eventEmitter)
      .then(() => {
        expect(Penpal.connectToParent).toHaveBeenCalled();
      });
  });

  it('uses the provided parent origin', () => {
    return connect(parentOrigin, eventEmitter)
      .then(() => {
        expect(Penpal.connectToParent).toHaveBeenCalledWith({
          parentOrigin,
          methods: expect.any(Object),
        });
      });
  });

  describe('on success', () => {
    let parentConnection: ParentConnection;
    let parent: Parent;

    beforeEach(() => connect(parentOrigin, eventEmitter).then(pc => (parentConnection = pc)));
    beforeEach(() => {
      const penpalConnection = (Penpal.connectToParent as jest.Mock).mock.results[0].value;
      return penpalConnection.promise.then((p: Parent) => (parent = p));
    });

    describe('parent connection', () => {
      describe('call', () => {
        it('calls a parent method', () => {
          const refreshChannel = jest.spyOn(parent, 'refreshChannel');
          return parentConnection.call('refreshChannel').then(() => {
            expect(refreshChannel).toHaveBeenCalled();
          });
        });

        it('resolves with the data returned by the parent method', () => {
          return parentConnection.call('getPage').then((page) => {
            expect(page.channel.id).toBe('testChannelId');
            expect(page.id).toBe('testPageId');
            expect(page.sitemapItem.id).toBe('testSitemapItemId');
            expect(page.url).toBe('http://www.example.com');
          });
        });

        it('rejects with error code "IncompatibleParent" when the parent method does not exist', () => {
          // @ts-ignore: noSuchMethod is not assignable
          return expect(parentConnection.call('noSuchMethod')).rejects
            .toMatchObject({
              code: 'IncompatibleParent',
              message: 'missing noSuchMethod()',
            });
        });

        it('rejects with error code "InternalError" when the parent method throws an error', () => {
          // @ts-ignore: noSuchMethod is not assignable
          jest.spyOn(parent, 'refreshChannel').mockImplementation(() => {
            throw new Error('boo');
          });

          return expect(parentConnection.call('refreshChannel')).rejects
            .toMatchObject({
              code: 'InternalError',
              message: 'boo',
            });
        });

        it('rejects with error code "ConnectionDestroyed" when the parent connection is destroyed', () => {
          jest.spyOn(parent, 'refreshChannel').mockImplementation(() => {
            // as generated by penpal
            throw Object.assign(
              new Error('Unable to send refreshChannel() call due to destroyed connection'),
              { code: Penpal.ERR_CONNECTION_DESTROYED },
            );
          });

          return expect(parentConnection.call('refreshChannel')).rejects
            .toMatchObject({
              message: 'Unable to send refreshChannel() call due to destroyed connection',
              code: 'ConnectionDestroyed',
            });
        });
      })
    });

    describe('event emitter', () => {
      it('emits events emitted by the parent', () => {
        const emitEvent = Penpal.connectToParent['mock'].calls[0][0].methods.emitEvent;
        const eventData = {};
        const listener = jest.fn();

        eventEmitter.on('event', listener);

        return emitEvent('event', eventData)
          .then(() => {
            expect(listener).toHaveBeenCalledWith(eventData);
          });
      });
    });
  });

  describe('on failure', () => {
    it('rejects with error code "NotInIframe" when there is no parent', () => {
      Penpal.connectToParent = () => {
        // as generated by penpal
        throw Object.assign(
          new Error('connectToParent() must be called within an iframe'),
          { code: Penpal.ERR_NOT_IN_IFRAME },
        );
      };

      return connect(parentOrigin, eventEmitter)
        .catch((error) => {
          expect(error).toBeInstanceOf(Error);
          expect(error.code).toBe('NotInIframe');
        });
    });
  });
});
